/**
 * From http://www.michaelbromley.co.uk/blog/350/exploring-es6-classes-in-angularjs-1-x?utm_content=buffer184f8&utm_medium=social&utm_source=plus.google.com&utm_campaign=buffer
 * Modified directive so that tmeplateUrl will work (_createFactoryArray), see https://github.com/michaelbromley/angular-es6/issues/1
 * Removed everything except directive
 */
var registerFn = function register(appName) {

    var app = angular.module(appName);

    return {
        directive: directive,
    };

    function directive(name, constructorFn) {

        constructorFn = _normalizeConstructor(constructorFn);

        if (!constructorFn.prototype.compile) {
            // create an empty compile function if none was defined.
            constructorFn.prototype.compile = () => {};
        }

        var originalCompileFn = _cloneFunction(constructorFn.prototype.compile);

        // Decorate the compile method to automatically return the link method (if it exists)
        // and bind it to the context of the constructor (so `this` works correctly).
        // This gets around the problem of a non-lexical "this" which occurs when the directive class itself
        // returns `this.link` from within the compile function.
        _override(constructorFn.prototype, 'compile', function () {
            return function () {
                originalCompileFn.apply(this, arguments);

                if (constructorFn.prototype.link) {
                    // use polyfill to monkeypatch Function.bind if not available
                    if (!Function.prototype.bind) {
                        console.log("Running in environment without bind support -- using polyfill to monkeypatch");
                        Function.prototype.bind = function (oThis) {
                            if (typeof this !== 'function') {
                                // closest thing possible to the ECMAScript 5
                                // internal IsCallable function
                                throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
                            }

                            var aArgs = Array.prototype.slice.call(arguments, 1),
                                fToBind = this,
                                fNOP = function () {},
                                fBound = function () {
                                    return fToBind.apply(this instanceof fNOP ? this : oThis,
                                        aArgs.concat(Array.prototype.slice.call(arguments)));
                                };

                            fNOP.prototype = this.prototype;
                            fBound.prototype = new fNOP();

                            return fBound;
                        };
                    }
                    // end polyfill
                    return constructorFn.prototype.link.bind(this);
                }
            };
        });

        var factoryArray = _createFactoryArray(constructorFn);

        app.directive(name, factoryArray);
        return this;
    }


    /**
     * If the constructorFn is an array of type ['dep1', 'dep2', ..., constructor() {}]
     * we need to pull out the array of dependencies and add it as an $inject property of the
     * actual constructor function.
     * @param input
     * @returns {*}
     * @private
     */
    function _normalizeConstructor(input) {
        var constructorFn;

        if (input.constructor === Array) {
            //
            var injected = input.slice(0, input.length - 1);
            constructorFn = input[input.length - 1];
            constructorFn.$inject = injected;
        } else {
            constructorFn = input;
        }

        return constructorFn;
    }

    /**
     * Convert a constructor function into a factory function which returns a new instance of that
     * constructor, with the correct dependencies automatically injected as arguments.
     *
     * In order to inject the dependencies, they must be attached to the constructor function with the
     * `$inject` property annotation.
     *
     * @param constructorFn
     * @returns {Array.<T>}
     * @private
     */
    function _createFactoryArray(constructorFn) {
        // get the array of dependencies that are needed by this component (as contained in the `$inject` array)
        var args = constructorFn.$inject || [];
        var factoryArray = args.slice(); // create a copy of the array

        // This was changed to work correctly with directives (templateUrl)
        factoryArray.push((...args) => {
            var directive = new constructorFn(...args);
            directive.link = directive.link;
            directive.compile = directive.compile;
            return directive;
        });

        return factoryArray;
    }

    /**
     * Clone a function
     * @param original
     * @returns {Function}
     */
    function _cloneFunction(original) {
        return function () {
            return original.apply(this, arguments);
        };
    }

    /**
     * Override an object's method with a new one specified by `callback`.
     * @param object
     * @param methodName
     * @param callback
     */
    function _override(object, methodName, callback) {
        object[methodName] = callback(object[methodName])
    }

}

export default registerFn;
